![image](https://github.com/user-attachments/assets/0e3b94b8-fcc9-4719-b911-c87dbd5eb962)12장에서 도커 스웜으로 서비스 만드는 데 모두 명령행 도구를 사용하느라 꽤 많은 시간이 들였다. 하지만 실무에서는 이런 일은 없을 것이다.<br>
실무에서는 애플리케이션을 YAML파일로 정의해 매니저 노드에 이 파일을 전달하는 방법을 쓴다.<br>
파일 포맷 자체는 컴포즈와 스웜 모두 지원할 수 있을 만큼 유연하므로, 이번 장에서는 도커 컴포즈와 도커 스웜에 대해 지금까지 배운 내용을 활용해 클러스터에서 분산 애플리케이션을 실행하는 방법을 알아볼 것이다.<br>

# 13.1 도커 컴포즈를 사용한 운영 환경

도커 스웜은 컴포즈를 만날 때 진정한 위력을 발휘한다. 운영 환경에서 개발 및 테스트 환경과 동일한 파일 포맷을 사용할 수 있기 때문이다. 모든 환경에서 전체 애플리케이션의 아티팩트와 도구를 동일하게 가져갈 수 있다.<br>
스웜에서 가장 간단한 형태의 배포는 컴포즈 파일 그자체다. 예제 13-1은 6장에서 다룬 to-do 애플리케이션의 이미지와 공개 포트 등 기본적인 배포 정보를 정의한 것이다.<br>
<br>

![image](https://github.com/user-attachments/assets/e2b5d7e0-4260-4c7b-ae14-9b359d0b57ad)

<br>
도커 컴포즈와 이 파일을 사용하면 단일 서버에 애플리케이션이 배포된다. 배포가 끝나면 공개된 포트를 통해 실행 중인 컨테이너에 접근해서 애플리케이션을 사용할 수 있다.<br>
스움에도 동일한 파일을 사용해 애플리케이션을 배포할 수 있다. 마찬가지로 배포가 끝나면 레플리카 하나를 실행 중인 서비스가 생성되고, 이서브스는 인그레스 네트워크를 통해 포트를 공개하고 있을 것이다.<br>
스웜모드에서 애플리케이션을 배포할 때 스택을 만든다. 스택이란 서비스, 네트워크, 볼륨 등 여러개의 도커 리소스를 묶어 만든 리소스를 만든다.<br>

[실습] 앞의 컴포즈 파일을 스택으로 배포해 보자. 먼저 스웜을 초기화한 다음, 이번 장의 예제 코드 디렉터리로 이동한다. 스택을 배포한 후 실행 중인 서비스의 상태를 확인하라.<br>

> cd ./ch13/exercise<br>
> 컴포즈 파일로 스택을 배포한다.<br>
> docker stack deploy -c ./todo-list/v1.yml todo<br>
> 스택의 목록에서 새로 생성된 스택을 확인한다<br>
> docker stack ls<br>
> 서비스의 목록을 확인해 새로 생성된 서비스를 확인한다<br>
> docker service ls<br>

<br>
그림 13-1에 나의 환경에서 실행한 결과를 실었다. 일반적인 도커 명령행으로 도커 스웜에 애플리케이션을 배포했지만 출력된 내용은 도커 컴포즈 때와 비슷하다.<br>
컴포즈 파일을 클러스터에 전달하니 매니저가 기본 네트워크를 생성하고 나서 서비스를 생성했다. 스택은 스웜모드의 일급 리소스다.<br>
<br>

![image](https://github.com/user-attachments/assets/9ca435af-acb6-41b0-84a9-7acab6ddfe78)

<br>
이 실습에서 중요한 점은 별도의 추가 설정 없이 컴포즈 파일만으로 스웜에 애플리케이션을 배포할 수 있다는 것이다.<br>
스웜에 노드가 두 개 이상이라면 고가용성을 확보할 수 있다. 여기서 말하는 고가용성이란 서비스 레플리카를 실행 중인 노드가 고장을 일으켜도 남아 있는 노드에서 대체 레플리카를 실행해 애플리케이션을 복구할 것이라는 의미다.<br>
<br>
스웜 모드에는 추가 기능이 더 있다. 이 기능을 사용하기 위해서는 deploy항목을 추가해야 한다.<br>
예제 13-2는 to-do 애플리케이션의 정의에 deploy 프로퍼티를 추가해 레플리카의 개수를 여러 개로 늘리되 한 레클리카의 계산 자원의 사용량을 제한하도록 설정한 것이다.<br>
<br>

![image](https://github.com/user-attachments/assets/b181c8cb-e2c0-4758-8f17-8f3ae927a377)

<br>
각 서비스가 차지할수 있는 계산 자원에 대한 상한을 설정해 두면 악의적인 레플리카 해당 노드의 게산 자원을 고갈시키는 것을 방지할수 있다.<br>
앞서 9장에서는 측정값을 통해 이러한 애플리케이션의 상태를 확인하는 방법을 배웠다. 여기서는 한 레플리카가 CPU 코어의 경우 코어 한 개의 50%, 매모리의 경우 100MB까지 점유할 수 있도록 설정했다.<br>

-- 스웜 스택에 업데이트를 적용하는 방법<br>
수정된 YAML파일을 매니저 노드에 전달하면 그내용 그대로 애플리케이션에 반영된다. 버전 v2 컴포즈 파일을 전달하면 스웜이 새로운 레플리카를 생성해 기존 레플리카를 대체하는 것을 볼 수 있다.<br>
<br>
[실습] 기존 스택의 정의를 수정한 새로운 컴포즈 파일을 stack deploy 명령을 사용해 애플리케이션에 반영하라. 서비스에서 진행 중인 작업 목록을 보면 이 과정을 확인할 수 있다.<br>

> 수정된 컴포즈 파일을 스웜에 전달한다.<br>
> docker stack deploy -c ./todo-list/v2.yml todo<br>
> 웹 서비스의 레플리카 상태를 확인한다.<br>
> docker service ps todo_todo-web<br>

나의 환경 실행한 결과를 그림13-12에 실었다. 실행결과에서 스택이 서비스를 업데이트해 레플리카가 교체되는 과정을 볼 수 있다.<br>
기존 레플리카는 컴포즈 파일에 추가한 계산 자원 제약으로 인해 컨테이너 정의가 수정되면서 새로운 컨테이너로 교체됐다.<br>
<br>

![image](https://github.com/user-attachments/assets/bc357d92-fd5c-42c6-8014-d7314b95b578)

<br>
스웜 스택은 애플리케이션을 그룹화하는 방법으로 활용된다. 클러스터는 일반저긍로 많은 수의 애플리케이션을 실행하기 때문에 애플리케이션도 그룹으로 만들어 관리해야 한다.<br>
도커 명령행에서 stack명령을 사용해 여러 애플리케이션을 하나의 대상으로 다루며, 각 서비스나 서비스의 레플리카 목록을 보거나 애플리케이션 전체를 한꺼번에 제거할 수도 있다.<br>
<br>
[실습] 스택은 애플리케이션을 관리하는 단위다. 각기 둘 이상의 레플리카를 실행하는 여러 서비스로 구성된 애플리케이션을 쉽게 다룰 수 있게 해 준다. to-do 애플리케이션 스택에서 실행 중인 서비스와 태스크를 확인하고 스택을 제거하라.<br>
<br>

> 스택의 서비스 목록 확인<br>
> docker stack services todo<br>
> 각 서비스의 레플리카 목록 확인<br>
> docker stack ps todo<br>
> 스택 제거<br>
> docker stack rm todo<br>

<br>
이 애플리케이션은 도커 네트워크와 하나의 서비스, 두개의 레플리카로 구성된 간단한 애플리케이션이다.<br>

<br>

![image](https://github.com/user-attachments/assets/7cfb1aa9-6acb-41b5-90d6-4a3a405c547f)

<br>
클러스터 데이터베이스에 애플리케이션에 대한 모든 정의가 들어 있기 때문에 따로 컴포즈 파일이 없어도 스택의 모든 리소스를 관리할 수 있다.<br>
매니저 노드느 모두 이 데이터베이스의 복본을 갖고 있기 때문에 다른 리소스에 대한 정보를 안전하게 보관할 수 있다. 컴포즈 파일에 포함된 애플리케이션 설정값도 바로 이 데이터베이스에 저장된다.<br>


# 13.2 컨피그 객체를 이용한 설정값 관리




# 13.3 비밀값을 이용한 대외비 설정 정보 관리하기



# 13.4 스웜에서 볼륨 사용하기



# 13.5 클러스터는 스택을 어떻게 관리하는가?



# 13.6 연습문제
