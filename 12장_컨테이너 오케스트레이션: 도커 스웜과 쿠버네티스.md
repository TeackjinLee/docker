오케스트레이션은 여러 대의 물리 서버에 걸쳐 컨테이너로 애플리케이션을 싱행하는 것을 말한다. 도커 이미지와 컴포즈 파일은 전과 같지만,<br>
컨테이너를 수동으로 직접 관리했던 이전과 비교하면 클러스터에 컨테이너 관리를 위임한다는 점이 다르다. 3부에서는 도커에 내장된 오케스트레이션 도구인 도커 스웜의 사용법을 배운다.<br>
그리고 애플리케이션 업데이트 및 롤백 절차, CI파이프라인을 클러스터와 연결해 지속적 통합에서 한 발짝 더 나아간 지속적 배포를 실현하는 방법도 알아본다.<br>

# 12.1 컨테이너 오케스트레이션 도구란?

도커 컴포즈는 단일 도커 호스트에서 컨테이너를 실행하기 위한 도구였다.<br>
하지만 운영 환경은 단일 호스트로만 구성되지 않는다. 단일 호스트는 한 대만 고장을 일으켜도 전체 애플리케이션이 중단된다.<br>
시스템은 고가용성을 요구, 이때 오케스트레이션이 필요.<br>
오케스트레이션 도구란 기본적으로 클러스터(cluster)를 구성하는 여러 대의 호스트 컴푸터를 의미, 컨테이너를 관리하는 도구이다.<br>

![image](https://github.com/user-attachments/assets/b6138e0b-0b40-4d6e-a7e0-26224843202c)

<br>
![image](https://github.com/user-attachments/assets/bb2bf119-0cc7-4e25-a7e8-7debd73ff841)
<br>
12-2그림에는 서버가 나타나 있지 않다. 오케스트레이션 도구가 각 서버, 네트워크, 스토리지 장치의 세부 사항을 가려 주기 때문이다.<br>
우리는 클러스터가 마치 하나의 대상인 것처럼 명령행 도구와 API를 통해 명령을 보내고 쿼리를 요청해 사용한다.<br>


# 12.2 도커 스웜으로 클러스터 만들기

[실습] 도커 CLI에는 클러스터 관리를 위한 명령도 준비돼있다. swarm init 명령을 사용하면 도커 엔진을 스웜 모드로 전환한다.<br>
      보통은 아무 인자 없이 사용하는 명령이지만, 호스트 컴퓨터가 하나 이상의 네트워크에 접속돼 있다면 스웜 통신에 사용할 IP주소를 선택하라는 메시지와 함께 오류를 일으킬 것이다.<br>

> docker swarm init<br>

![image](https://github.com/user-attachments/assets/aba8eb85-8601-4f9a-a4e2-bcd9b31a105f)

<br>
출력된 내용을 보면, 도커 스웜이 초기화 되고 나의 컴퓨터가 클러스터 매니저가 됐다.<br>
클러스터에 속한 컴퓨터는 매니저와 워커라는 두가지 역할 중 하나를 맡는다. 출력된 내용 중에는 다른 컴퓨터를 클러스터에 워커로 참여 시키기 위해 입력할 명령어도 있다.<br>

매니저 : 클러스터를 관리하는 작업을 직접 수행한다. 클러스터 데이터베이스 매니저 노드에 저장되며, 사용자가 YAML 파일을 전달하기 위해 사용하는 API도 매니저 노드에서 동작하고 컨테이너 모니터링과 스케줄링 모두 매니저 노드가 수행한다.<br>
워커 : 매니저의 스케줄링에 따라 컨테이너를 실행하고 그 상태를 주기적으로 매니저에 보고하는 역할을 하는데, 매니저도 워커의 역할을 수행할 수는 있다.<br>
스웜을 만들고 나면 원하는 만큼 컴퓨터를 스웜을 추가할 수 있다.<br>
스웜에 추가된 컴퓨터를 노드라고 부른다.<br>
스웜에 노드를 추가하기 위한 조건,<br> 
1. 해당 컴퓨터가 스웜과 같은 네트워크상에 있어야 한다.<br>
2. 스웜에 들어가기 위한 패스워드 역할을 하는 참가 토큰을 매니저로쿠터 발급 받아야 한다.<br>
[실습] 도커 엔진을 스웜 모드로 전환하고 나면, 도커 CLI에서 사용할 수 있는 새로운 명령이 많다. 이들 명령을 사용해 워커용 참가 토큰과 매니저용 참가 토큰을 각각 출력해 보고 스웜에 현재 참여 중인 노드의 목록도 확인하라.<br>

> 워커 노드로 스웜에 참여하기 위한 명령을 화면에 출력<br>
> docker swarm join-token worker<br>
> 매니저 노드로 스웜에 참여하기 위한 명령을 화면에 출력<br>
> docker swarm join-token manager<br>
> 스웜에 참여 중인 노드의 목록을 출력<br>
> docker node ls<br>

![image](https://github.com/user-attachments/assets/9fefb9bf-5593-44e8-afc3-f42b64048dff)

<br>
단일 노드 스웜도 노드가 여러 개인 스웜과 같은 방식으로 동작한다. 다른 점이 있다면, 노드가 하나인 만큼 노드가 여러 개인 스웜에 비해 높은 가용성을 가질수는 없으며 컨테이너 수를 원하는 만큼 증가시키는 스케일링이 불가능하다는 점이다.<br>
그림 12-15는 개발 환경과 테스트 환경에 적합한 단일 노드 스웜과 운영 환경에 사용되는 노드가 여러개인 클러스터를 비교한 것이다.<br>

![image](https://github.com/user-attachments/assets/8faf51c2-f404-4c1d-b59e-889848b3f56d)

<br>
도커 스웜이 쿠버네티스보다 나은 점 중 하나는 클러스터를 구성하고 관리하는 작업이 단순하다는 것이다.<br> 
1. 수십 대 정도 규모의 스웜을 각 호스트마다 도커를 설치하고 
2. 매니저 노드를 맡을 컴퓨터에서 docker swarm init 명령을 한번 실행<br>  
3. 나머지 노드에서 docker swarm join 명령을 실행하는 정도면 만들수 있다. 운영 환경에서도 더 복잡한 작업은 필요 없다.<br>

이제 단일 노드 스웜을 만들었으니 컨테이너 오케스트레이션의 관리 아래에서 애플리케이션이 어떻게 동작하는지 알아보자<br>

# 13.3 도커 스웜 서비스로 애플리케이션 실행하기

하나의 서비스가 여러개의 컨테이너로 배포될 수 있다는 점에서 스웜에서 말하는 서비스는 컴포즈에서 말하는 서비스와 의미가 같다.<br>
서비스는 컨테이너와 같은 정보로 정의된다. 사용되는 이미지, 환경변수와 값, 공개되는 포트와 같은 정보다. 여기에 서비스의 이름이 도커 네트워크상에서 그대로 도메인으로 사용된다는 점도 컨테이너와 같다.<br>
차이점이라면, 서비스는 여러 개의 레플리카(서비스와 똑같이 설정되지만 스웜상의 여러 노드에 흩어져 배치될 수 있다)를 가질수 있다는 점이다.

[실습] 도커 허브에 있는 이미지로 컨테이너 하나를 실행하는 서비스를 만들어라. 그리고 서비스 목록을 확인해 새로 실행한 서비스가 제대로 실행 중인지 확인해 보자.<br>

> docker service create --name timecheck --replicas 1 diamol/ch12-timecheck:1.0<br>
> docker service ls<br>

서비스는 도커 스웜의 일급 객체이지만, 서비스를 다루려면 도커 엔진이 스웜 모드이거나 스웜 매니저에 연결된 상태여야 한다.<br>
실행 결과를 보면 서비스가 생성되고 서비스 목록에서 서비스의 기본적인 정보가 출력된다. 이 서비스는 하느의 레플리카를 실행 중임을 알 수 있다.<br>

![image](https://github.com/user-attachments/assets/fead60d2-87b4-48bc-84de-d9ba158c075a)

<br>
서비스를 구성하는 컨테이너를 레플리카(replaca)라고 부른다. 그러나 레플리카는 뭔가 특별한 것이 아니라 평범한 도커 컨테이너다.<br>
노드가 하나뿐인 스웜에서는 모든 레플리카가 같은 서버에서 실행되므로 지금 만든 서비스 컨테이너를 바로 다룰 수 있다.<br>
컨테이너 관리를 스웜이 대신해 주니 컨테이너를 직접 다룰 일이 많지는 않겠지만, 그럴 필요가 있다면 직접 다룰 수 있다.<br>

[실습] 서비스 레플리카가 현재 실행 중이지만, 스웜이 레플리카의 관리를 맡고 있다. 직접 컨테이너를 삭제해 보면 스웜이 레플리카 수가 부족해졌다고 판단하고 새로운 컨테이너를 실행한다.<br>
> 이 서비스의 레플리카 목록을 확인한다.<br>
> docker service ps timecheck<br>
> 현재 컴퓨터에 실행 중인 컨테이너를 확인한다<br>
> docker container ls<br>
> 가장 최근에 생성한 컨테이너(래플리카)를 삭제한다.<br>
> docker container rm -f $(docker container ls --last 1 -q)<br>
> 레플리카 목록을 다시 확인한다.<br>
> docker service ps timecheck<br>

![image](https://github.com/user-attachments/assets/3fc3ef3e-dc24-4a9e-be29-03f19ac1386b)

<br>
도커 엔진을 스웜 모드로 전환했다면, 애플리케이션을 서비스로 보고 각각의 컨테이너를 관리하는 것은 스웜에 맡겨야 한다.<br>
모든 컨테이너를 직접 관리하려면 스웜에 참가 중인 노드에 일일이 접속해 해당 노드가 서비스에 포함되는 레플리카를 실행 중인지 확인 후 컨테이너를 관리해야 하는데, 이것이 사실상 불가능하기 때문이다.<br>
그 대신 도커가 스웜 리소스를 관리할 수 있는 명령을 제공한다. docker service 명령을 사용해 레플리카의 로그를 확인하거나 서비스의 구성을 확인할 수 있다.<br>
<br>
[실습] 스웜 모드에서 docker service 명령을 사용해 애플리케이션을 관리한다. 이 명령으로 레플리카의 로그 같은 각 레플리카의 정보나 서비스에 대한 전반적인 정보를 확인할 수 있다.<br>

> 최근 10초간의 로그를 출력한다.<br>
> docker service logs --since 10s timecheck<br>
> 서비스의 정보 중 이미지 정보를 출력한다.<br>
> docker service inspect timecheck -f '{{.Spec.TaskTemplate.ContainerSpec.Image}}'<br>

<br>

![image](https://github.com/user-attachments/assets/6f03e55c-d67f-4493-a7d4-702183e9a6c1)

<br>
서비스 전체의 구성 정보는 클러스터에 저장돼 있으므로, 포맷 파라미터 없이 service inspect 명령을 입력하면 확인할 수 있다.<br>
클러스터 데이터베이스에는 상당히 많은 정보가 들어 있는데, 이들 정보는 안전하게 암호화돼 모든 매니저 노드마다 복제본이 위치한다.<br>
도커 컴포즈가 도커 스웜과 가장 크게 다른 점은 애플리케이션 정의를 저장할 공간을 갖지 않는다는 것이다.<br>
<br>

[실습] timecheck 서비스의 이미지 버전을 변경하라. 새 버전은 이전 버전과 마찬가지로 몇 초에 한번씩 타임스탬프 값을 출력하지만, 로그에 애플리케이션 버전이 삽입된다.<br>

> 서비스에 사용된 이미지 버전을 수정한다.<br>
> docker service update --image diamol/ch12-timecheck:2.0 timecheck<br>
> 서비스 래플리카 목록을 확인한다.<br>
> docker service ps timecheck<br>
> 래플리카 로그도 확인한다.<br>
> docker service logs --since 20s timecheck<br>

<br>
각 로그에는 레플리카의 식별자가 달려 있어 어느 레플리카에서 출력한 것인지 알 수 있다. 이 로그는 애플리케이션에서 컨테이너에 남긴 것으로, 스웜이 이를 다시 수집하고 레플리카 식별자를 달아 보여 주는 것이다.<br>
<br>

![image](https://github.com/user-attachments/assets/47a05fd6-40b3-40e4-b6dc-1ef63f46975f)

<br>
모든 컨테이너 오케스트레이션 도구는 애플리케이션을 업데이트할 때 애플리케이션을 중단시키지 않고 점진적으로 컨테이너를 교체해 나가는 롤링 업데이트 방식을 사용한다.<br>
그림 12-10 롤링 업데이트가 진행 중인 서비스의 상태를 나타낸 것이다.<br>
<br>

![image](https://github.com/user-attachments/assets/769773f4-bf25-40ab-ade3-0ac44a6c5d41)

<br>
스웜의 데이터베이스는 이전 버전의 서비스 정의 내용이 남아 있으므로 명령 한 번으로 이전 버전으로 롤백할 수 있다.<br>
<br>

[실습] 배포 작업 중 이상이 발생하면 이전 상태로 롤백하는 경우가 많다. 도커 스웜도 애플리케이션의 이전 상태를 저장하고 있기 때문에 애플리케이션 롤백 기능을 제공한다.<br>
<br>

> 어전 버전으로 롤백<br>
> docker service update --rollback timecheck<br>
> 레플리카의 목록 확인<br>
> docker service ps timecheck<br>
> 최근 25초 동안 모든 레플리카의 로그 출력<br>
> docker service logs --since 25s timecheck<br>

<br>
롤백 과정도 업데이트와 같이 롤링을 거친다.<br>
<br>

![image](https://github.com/user-attachments/assets/99543611-dcae-46f3-b581-292e9ca88188)

<br>
스웜 모드에서는 컨테이너보다는 서비스를 주로 다룬다. 서비스 외에도 스웜 모드에서 다루게 되는 도커 리소스가 몇가지 더 있지만, 핵심이 되는 것들은 전과 같은 방법으로 사용할 수 있다.<br>
스웜 모드에서는 컨테이너는 도커 네트워크를 통해 통신하며 외부 트래픽을 공개된 포트만 컨테이너로 전달된다.<br>

# 13.4 클러스터 환경에서 네트워크 트래픽 관리하기

컨테이너에서 실행되는 애플리케이션 입장에서 스웜 모드의 네트워크는 표준 TCP/IP 방식이다.
컴포넌트 도메인 네임으로 서로를 식별,
<br>
그림 12-12는 서로 다른 애플리케이션이 두 개의 오버레이 네트워크에서 동작하는 상황을 나타낸 것이다. 각 애플리케이션은 여러 노드에 걸쳐 실행되는 여러 개의 서비스로 구성된다.<br>
같은 애플리케이션에 속하는 서비스는 오버레이 네트워크를 통해 통신이 가능하지만, 오버레이 네트워크 자체는 서로 독립적이기 때문에 서로 다른 네트워크에 속한 서비스는 통신이 불가능한다.<br>
<br>

![image](https://github.com/user-attachments/assets/e76fcbfb-1638-48d3-a39e-c36a30f98ae9)

<br>
[실습] 기존에 실행 중인 애플리케이션을 제거하고 새로운 네트워크와 앞 장에서 배운 NASA의 오늘의 천문 사진 애플리케이션의 컴포넌트 중 API 서비스를 실행한다.<br>
<br>

> 기존에 실행 중인 애플리케이션을 제거한다<br>
> docker service rm timecheck<br>
> 새로운 오버레이 네트워크를 만든다<br>
> docker network create --driver overlay iotd-net<br>
> 오늘의 천문 사진 애플리케이션의 API 서비스와<br>
> docker service create --detach --replicas 3 --network iotd-net --name iotd diamol/ch09-image-of-the-day<br>
> 로그 API를 실행해 같은 네트워크에 연결한다<br>
> docker service create --detach --replicas 2 --network iotd-net --name accesslog diamol/ch09-access-log<br>
> 서비스 목록을 확인한다<br>
> docker service ls<br>

<br>
그림 12-13을 보면, 이중 이미지 API 서비스는 세개의 레플리카를 실행 중이고 로그 서비스는 두 개의 레플리카를 실행 중이다.<br>
현재는 서비스를 도커 데스크톱으로 만든 단일 노드 스웜에서 실행 중이지만, 500대의 노드를 가진 스웜에서도 같은 명령을 사용하면 완전히 같은 겨로가를 얻을 수 있다.
<br>

![image](https://github.com/user-attachments/assets/af9e635f-e8a1-4e8f-83fe-b66ed416a646)

<br>
[실습] 가장 최근에 실행한 컨테이너에서 대화식 터미널 창을 열고, API 서비스에 대해 DNS 조회를 요청하라. 첫 번째 명령의 경우 윈도 컨테이너와 리눅스 컨테이너에서 다른 명령이 쓰이지만, 터미널을 통해 컨테이너에 접속하고 나면 나머지 명령은 동일하다.<br>
<br>

> 컨테이너에 터미널로 접속한다(윈도 컨테이너)<br>
> docker container exec -it $(docker container ls --last 1 -q) cmd<br>
> 컨테이너에 터미널로 접속한다(linux contaienr)<br>
> docker container execc -it $(docker container ls --last 1 -q) sh<br>
> DNS 조회하기<br>
> nslookup iotd<br>
> nslookup accesslog<br>

12-14그림을 보면 서비스가 여러개의 컨테이너를 실행함에도 각 서비스마다 IP주소가 하나씩 조회됐다. 이 IP주소는 가상 IP주소로, 서비스에 속하는 모든 레플리카가 공유하는 주소다.<br>

<br>

![image](https://github.com/user-attachments/assets/566d7cf1-7630-44df-872f-1bf0e43c46c6)₩

<br>
VIP네트워크는 리눅스와 윈도 두 환경 모두 지원, 로드벨런싱에 유리, DNS조회 결과에는 IP 주소가 하나만 조회됐다. 클라이언트가 이 IP 주소로 요청을 보내면,<br> 
운영체제의 네트워크 계층에서 이 IP 주소의 종착점이 여러 곳임을 파악하고 그중 하나만 결정해 준다.<br>
<br>

스웜은 클러스터에 인입되는 요청을 웹 애플리케이션 컨테이너를 실행 중인 노드로만 전달해야 한다.<br> 
반대로 클러스터의 노드가 다섯 개뿐이라면 한 노드에서 컨테이너를 여러개 실행 중일 것이므로 한 노드에서 실행 중인 컨테이너끼리도 로드 밸런싱을 해야 한다.<br>
스웜은 인그레스 네트워킹을 이용해 이런 문제를 해결한다.<br>
그림 12-15는 인그레스의 동장 방식을 보여준다. 그림을 보면 모든 노드가 같은 포트를 감시하며 외부 트래픽을 받고, 이렇게 노드에 도달한 트래픽에 대한 내부적인 로드 밸런싱을 도커가 맡는 식이다.
<br>

![image](https://github.com/user-attachments/assets/7eb27ba3-f38b-4525-a64f-fa797a87a342)

<br>
서비스의 포트를 공개하면 인그레스 네트워크가 기본적으로 적용된다. 네트워크가 그랬든 복잡한 기술을 쉽게 적용할 수 있다.<br>
서비스를 생성할 때 공개할 포트를 지정하기만 하면 인그레스 네트워크를 사용할 수 있다.<br>

[실습] NASA 오늘의 천문 사진 애플리케이션의 마지막 구성 요소인 웹 애플리케이션을 실행할 차례다. 웹 애플리케이션을 스웜 서비스 형태로 실행하고 공개할 포트를 지정하면, 인그레스 네트워크가 적용된다.

> 웹 프론트엔드 실행한다<br>
> docker service create --detach --name image-gallery --network iotd-net --publish 8010:80 --replicas 2 diamol/ch09-image-gallery<br>
> 서비스의 목록 확인
> docker service ls<br>

<br>
이제 여러 개의 레플리카가 하나의 포트를 감시 중인 서비스를 실행했다. 도커 컴포즈로는 여러 컨테이너가 같은 포트를 감시하도록 할 수 없기 때문이 이 같은 일이 불가능하다.<br>
하지만 도커 스웜에서는 인그레스 네트워크를 사용해 서비스 하나가 포트 하나를 사용하는것이 가능하다.<br>

<br>

![image](https://github.com/user-attachments/assets/d89df291-86d1-41ab-a649-0091f5425d57)

<br>

애플리케이션 배포와 관리에 클러스터 크기는 그리 영향을 주지 못한다.

# 13.5 도커 스웜과 쿠버네티스 중 무엇을 사용할까?

도커 스웜은 상대적으로 기능이 간단한 컨테이너 오케스트레이션 도구로 설계됐다.

쿠버네티스 : 확장성이 뛰어나서 클라우드 사업자가 로드벨러서, 스토리지 등과 같은 애플리케이션 배포를 지원하는 자사 프로덕트와 통합하기에 유리하다.<br>
도커 스웜 : 쿠버네티스와 달리 확장성이 부족해 자사 프로덕트와 통합하기 곤란하다는 점도 한가지 이유다. 그림 12-18 마이크로소프트 애저 클라우드에서 도커 스웜을 직접 운영하기 위해 필요한 주요 클라우드 지원을 나타낸 것이다.<br>
<br>

![image](https://github.com/user-attachments/assets/500302e2-6976-4cf7-b3f1-dd5a9a4e1f34)

<br>
클러스터 생성은 아무래도 애플리케이션 배포보다는 빈도가 적다. 하지만 반복적으로 해야 하는 업무일 때는 도커 스웜을 사용하는 편이 훨씬 간편하다.<br>
쿠버네티스에 비해 기능은 상대적으로 부족하지만 훨씬 쉽게 실제 업무에서 필요한 기능의 대부분을 사용할 수 있다.<br>

스웜에서 쿠버네티스로의 이주시 참고기준될 만한 사항.

<ul>
      <li>인프라스트럭어: 애플리케이션ㅇ르 클라우드 환경에 배포하고 있다면, 쿠버네티스가 더 적합하다. 하지만 온프레미스 환경이라면 관리 면에서 스웜이 훨씬 간결하다.<br>
      그리고 현재 조직의 기반이 윈도 기반이라면, 스웜을 선택해야 리눅스를 도입하지 않고도 이전할 수 있다.
      </li>
      <li>학습곡선: 스웜의 사용자 경험은 도커와 도커 컴포즈의 연상선상에 있어 학습 부하 면에서 스웜으로 이전하는 것이 유리하며, 쿠버네티스는 전혀 새로운 도구를 학습해야 하는 부담이 있으므로 개발 팀 모두가 받아들이기 어렵다.</li>
      <li>기능 : 쿠버네트스의 사용법이 복잡한 이유는 그만큼 세세하게 설정할 수 있는 기능이 많기 때문이다. 예를 들어 불루-그린 배포나 자동스케일링. 역할 기반접근제어 같은 기능이 쿠버네티스에는 쉽게 적용할 수 있는 반면, 
      스웜에는 적용하기가 까다록다.
      </li>
      <li>미래를 위한 투자: 쿠버네티스의 오픈 소스 커뮤니티는 매우 활동적이므로 규모도 업계 최대다. 스웜은 신규 기능이 추가되지 않은 지 좀 됐고, 쿠버네티스는 추가 기능이 계속 업데이트 중이다.</li>
</ul>
<br>

결국 기술 로드맵의 종착점은 쿠버네티스가 될 것이다.

# 연습문제











































