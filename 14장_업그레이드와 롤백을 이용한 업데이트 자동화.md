# 14.1 도커를 사용한 애플리케이션 업그레이드 프로세스

도커 이미지는 믿을수 없을만큼 단순한 패키징 포맷이다. 배포 주기는 애플리케이션 버전을 제외하고도 최소한 다음 네가지 주기를 고려해야 한다.<br>
첫 번쨰는 의존 모듈 업데이트<br>
두 번째는 애플리케이션 코드를 컴파일하는 데 사용하는 SDK 업데이트<br>
세 번째는 애플리케이션이 동작하는 플랫폼의 업데이트<br>
네 번쨰는 운영체제 업데이트<br>
그림 14-1은 리눅스에서 동작하는 닷넷 코어 애플리케이션의 여섯가지 업데이트 주기를 정리한 것이다<br>
<br>

<img width="50%" src="https://github.com/user-attachments/assets/0e48e675-de25-445c-bd52-c30846c8d8e0" />

<br>
이번 장은 8장에서 다뤘던 무작위 숫자 애플리케이션을 소재로 10장에서 배운 오버라이드 컴포즈 파일을 이용해 이 과정을 체험해 보겠다.<br>
결과물은 애플리케이션 정의만이 포함된 깔끔한 코어 컴포즈 파일 하나와 업데이트를 정의한 추가 파일이 될 것이다.<br>
여러 개로 나뉜 컴포즈 파일은 스택 배포에 사용할 수 없다. 그러므로 먼저 오버라이드 파일을 하나의 컴포즈 파일로 병합하는 방법부터 알아보자.<br>
<br>

[실습] 먼저 무작위 숫자 애플리케이션의 첫 빌드를 배포하는 것부터 시작해 보자. 웹 서비스는 한 개 컨테이너, API 서비스는 여섯 개 레플리카로 실행한다.<br>
      컨테이너 상태를 통해 롤링 업데이트의 진행 과정을 알 수 있을 것이다. 도커 엔진은 스웜 모드로 전환한다. 그리고 컴포즈 파일을 병합하고 병합한 파일로 스택을 배포한다.<br>
<br>

> cd ch14/exercises<br>
> 코어 컴포즈 파일과 오버라이드 파일을 병합한다.<br>
> docker-compose -f ./numbers/docker-compose.yml -f ./numbers/prod.yml config > stack.yml<br>
> 병합된 컴포즈 파일로 스택을 배포한다.<br>
> docker stack deploy -c stack.yml numbers<br>
> docker stack services numbers<br>

<br>

![image](https://github.com/user-attachments/assets/821d4e41-4fc3-4cc4-b21b-ff8f680250db)

<br>
그림 14-2를 보면 스택에 대해 우리가 아직 배우지 않은 내용이 있다. API 서비스는 일반적인 replicated 모드로 실행 중인데, 웹 서비스는 global 모드로<br>
실행 중이라고 나온다. global 모드로 동작하는 서비스는 한 노드에 레플리카를 하나만 실행한다. 이모드는 인그레스 네트워크를 우회하기 위한 목적으로 사용하는데 리버스 프록시 같은 상황에서 유용하게 사용할 수 있는 모드다.<br>
인그레스 네트워크 : 인그레스 네트워크는 클러스터 외부에서 들어오는 트래픽을 내부 서비스로 라우팅하는 데 사용되는 네트워크로, Docker Swarm과 Kubernetes와 같은 컨테이너 오케스트레이션 도구에서 중요한 역할을 합니다.<br>
리버스 프록시 : 리버스 프록시는 클라이언트의 요청이 직접 원본 서버로 전달되는 대신, 먼저 프록시 서버로 전달된 후 프록시 서버가 해당 요청을 처리하거나 원본 서버로 전달합니다. 그 후, 원본 서버로부터 받은 응답을 다시 클라이언트에게 전달합니다.<br>
<br>
롤링 업데이트 과정에서 replicated 모드와 차이를 보여주기 위한 목적으로 사용했다. 웹 서비스에 대한 설정은 예제 14-1과 같다.(prod.yml에서 발췌)
<br>

![image](https://github.com/user-attachments/assets/84fc6507-c3f6-4183-88f0-f045bcf741e1)

<br>
이 설정에서 서비스를 global 모드로 설정하는 부분은 다음 두 필드다.<br>
<ul>
  <li>mode: global: deploy 항목에 이 필드 설정을 추가하면 해당 서비스는 한 노드에서 한 개의 컨테이너만 실행 된다. 레플리카의 수는 노드의 수와 같으므로 클러스터에 새로 추가된 노드에서 컨테이너가 실행된다.</li>
  <li>mode: host: ports 항목에 이 필드 설정을 추가하면 해당 서비스를 인그레스 네트워크 대신 호스트의 80번 포트와 연결한다. 한 노드에 레플리카 하나만으로도 무방한 가벼운 웹 애플리케이션이거나 네트워크 성능이 매우 중요해서 인그레스 네트워크 내 라우팅에 따른 오버헤드를 제거하고 싶다면 유용하게 사용할 수 있는 패턴이다.</li>
</ul>

<br>

[실습] 이제 버전 v2 컴포즈 파일과 헬스 체크 설정이 추가된 오버라이드 파일, 운영환경용 어버라이드 파일을 병합해 보자. 그리고 스택을 다시 배포하라.<br>

> 헬스 체크, 운영환경 설정 오버라이드 파일과 v2 버전 파일을 병합한다.<br>
> docker-compose -f ./numbers/docker-compose.yml -f ./numvers/prod.yml -f ./numbers/prod-healthcheck.yml -f ./numbers/v2.yml --log-level ERROR config > stack.yml<br>
> 스택을 업데이트 한다.<br>
> docker stack deploy -c stack.yml numbers<br>
> 스택의 레플리카 상태를 확인한다.<br>
> docker stack ps numbers<br>

<br>

![image](https://github.com/user-attachments/assets/f78c7436-435f-4515-af3d-1e55da21debb)

<br>





# 14.2 운영 환경을 위한 롤링 업데이트 설정하기




# 14.3 서비스 롤캑 설정하기




# 14.4 클러스터의 중단 시간




# 14.5 스웜 클러스터의 고가용성




# 14.6 연습문제
